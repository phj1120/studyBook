# 불필요한 객체 생성을 피하라

```
객체의 생성은 비싸니 피해야 된다로 오해하지 말 것. 요즘은 큰 부담 안됨

프로그램의 명확성, 간결성, 기능을 위해 객체를 추가하는 것은 일반적으로 좋은 일임.
```

### 객체가 불변이라면 재사용 해도 안전함이 명백

불변 객체의 재사용은 언제나 가능

생성자 대신 정적 팩터리 메서드를 제공하는 불변 클래스를 이용해, 불필요한 객체 생성을 피할 수 있음.

가변 객체일지라도 사용 중에 변경 되지 않을 것을 안다면 재사용 가능

### 생성 비용이 비싼 객체가 반복해서 필요하다면 캐싱해서 재사용

Ex) Pattern

```
public class RomanNumerals {
    private static final Parttern ROMAN = Parttern.compile("~~~");
    
    static boolean isRomanNumeral(String s){
        Return ROMAN.matchers(s).matches();
    }
}
```

isRomanNumeral 를 한 번도 사용하지 않는 다면 불필요하게 초기화 되었다고 볼 수도 있다.

그렇다고 이 문제를 해결하기 위해 지연 초기화로 불필요한 초기화를 없앨 수 있지만,

지연 초기화를 통해 코드를 복잡하게 만드는데 비해 성능이 크게 개선 되지 않기 때문에 권장하지 않음

### 어댑터(뷰)

실제 작업은 뒷단 객체에 위임하고, 자신은 제 2의 인터페이스 역할을 해주는 객체

뒷단 객체 외에는 관리할 상태가 없으므로, 뒷단 객체 하나당 어댑터 하나씩만 만들어지면 됨.

Map 의 keySet() 은 매번 같은 Set 인스턴스를 반환한다.

```
public Set<K> keySet() {
    Set<K> ks = keySet;
    if (ks == null) {
        ks = new KeySet();
        keySet = ks;
    }
    return ks;
}
```

모두 같은 Map 의 인스턴스를 대변하기 때문

### 오토박싱

박싱된 기본 타입 보다는 기본타입을 사용하고, 의도치 않은 오토 박싱이 숨어들지 않도록 주의

### Item50. 방어적 복사와의 차이

item06. 기존 객체를 재사용 해도 된다면 새로운 객체를 만들지 마라

item50. 새로운 객체를 만들어야 한다면 기존 객체를 재사용 하지마라

방어적 복사 공부 후 다시 보기.