# 상속보다는 컴포지션을 사용하라.

```
상속은 상위 클래스와 하위 클래스가 순수한 is-a 관계일 때만 써야한다.
상위 클래스가 확장을 고려해 설계 되지 않았다면 여전히 문제가 있다.

상속의 취약점을 피하려면 Composition(조합) 과 Forward(전달)을 사용하자.
특히 래퍼 클래스로 구현할 적당한 인터페이스가 있다면 더욱 그렇다.
Wrapper 클래스는 하위 클래스보다 견고하고 강력하다.
```

상속은 코드를 재사용하는 강력한 수단이지만, 잘 못 사용하면 오류를 내기 쉽다.

안전하게 상속(아이템19) 할 수 있지만,

다른 패키지의 구체 클래스를 extends 하는 것은 위험하다.

## 상속이 위험한 이유

* 메서드를 어떻게 Override 하느냐에 따라 동작이 달라 질 수 있음.
  ex) 예시 코드의 HashSet 의 addAll
* 상위 클래스에 새로운 메서드를 추가할 경우, 하위 클래스에서도 수정이 필요할 수 있음.
  ex) 상위 클래스에서 검증 후 원소를 추가하는 로직이 추가 되었을 경우
  하위 클래스의 메서드를 이용해 검증 되지 않은 원소가 추가 될 수 있다.
  상위 클래스에서 하위 클래스의 메서드 시그니처가 같고 반환 값이 다른 메서드를 추가할 경우 컴파일 실패 할 수 있음

## 해결 방법

Composition(조합)을 이용하자

* 구현
  새로운 클래스를 만들고 private 필드로 기존 클래스의 인스턴스를 참조 하도록하고,

  새 클래스의 인스턴스는 기존 클래스의 대응하는 메서드를 호출해 반환 하도록 한다.

* 효과
  새로운 클래스는 기존 클래스의 내부 구현 방식의 영향에서 벗어나며

  기존 클래스에 새로운 메서드가 추가 되더라도 영향을 받지 않음

* 구현 예시
    * Wrapper Class (래퍼 클래스)
      다른 인스턴스를 감싸고 있는 클래스
    * Forwarding Class (전달 클래스)
      기존 클래스의 인스턴스를 private 필드로 가지고 있고,
      기존 클래스의 메서드를 호출해 반환해 주는 클래스

다른 클래스에 계측 기능을 덧 씌운다는 뜻에서 데코레이터 패턴이라 부름

Composition 과 Forward 의 조합을 Delegation (위임) 이라고 부름

전달 메서드들을 만드는 것이 지루 할 수는 있지만,

재사용 할 수 있는 전달 클래스를 인터페이스당 하나씩만 만들어두면,

원하는 기능을 덧씌우는 전달 클래스들을 손쉽게 구현할 수 있음

## 상속

상속은 반드시 하위 클래스가 상위 클래스의 진짜 하위 타입인 상황에서만 쓰여야함

클래스 B 가 클래스 A 와 is-a 관계 일때만 클래스 A 를 상속 해야 한다.

상위 클래스의 API 에 아무런 결함이 없는가?

있다면, 이 결함이 하위 클래스의 API 까지 전파되어도 괜찮은가? 생각해보기

